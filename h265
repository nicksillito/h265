#!/usr/bin/env python3

# h265 & av1 -- converts a video file to the new format

# to use av1 needs to be linked to h265. Calling program name selects video codec

import subprocess
import json
import argparse
import sys
import shlex
import re
import tempfile
from pathlib import Path
import shutil

class FFProbe:

    def __init__(self, video_file):
        if not video_file.is_file:
            raise OSError(str(video_file) + ' not found')
        probe = subprocess.Popen([ 'ffprobe', '-print_format', 'json', '-show_streams',
         video_file ], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        self.probe=json.load(probe.stdout)


    def streams(self):
        return len(self.probe['streams'])


    def codec_type(self, stream):
        return self.probe['streams'][stream].get('codec_type')


    def codec_name(self, stream):
        return self.probe['streams'][stream].get('codec_name')


    def channels(self, stream):
        return self.probe['streams'][stream].get('channels')


    def default(self, stream):
        return self.probe['streams'][stream]['disposition'].get('default', 0)


    def language(self, stream):
        try:
            return self.probe['streams'][stream]['tags']['language'].lower()
        except:
            return None


    def width(self, stream):
        return self.probe['streams'][stream].get('width')
 

    def height(self, stream):
            return self.probe['streams'][stream].get('height')


    def duration(self, stream):
        if 'duration' in self.probe['streams'][stream]:
            return float(self.probe['streams'][stream]['duration'])
        elif 'tags' in self.probe['streams'][stream] and 'DURATION' in self.probe['streams'][stream]['tags']:
            h, m, s = self.probe['streams'][stream]['tags']['DURATION'].split(':')
            return float(h)*3600+float(m)*60+float(s)
        elif 'tags' in self.probe['streams'][stream] and 'language' in self.probe['streams'][stream]['tags'] and \
            'DURATION-'+self.probe['streams'][stream]['tags']['language'] in self.probe['streams'][stream]['tags']:
            h, m, s = self.probe['streams'][stream]['tags']['DURATION-'+self.probe['streams'][stream]['tags']['language']].split(':')
            return float(h)*3600+float(m)*60+float(s)
        else:
            return None


    def sourceid(self, stream):
        return self.probe['streams'][stream]['tags'].get('SOURCE_ID-eng')


    def bytes(self, stream):
        return int(self.probe['streams'][stream]['tags'].get('NUMBER_OF_BYTES-eng', 0))


    def prefer_audio(self, lang=None, xlang=['nar', 'NAR']):
        # lang is a list of preferred languages (eg ['eng', 'fre']) or None
        # xlang is a list of languages to be excluded if lang is None
        # Returns a list of the audio tracks matching the specified language
        # or all audio tracks if lang is specified as None
        # By default, this will accept all language tracks except nar (narration)
        selected=[]
        streamIDs={}    # Dictionary of known stream IDs
        for stream in range(self.streams()):
            if self.codec_type(stream)=='audio' and (lang==None and not self.language(stream)
            in xlang or lang!=None and self.language(stream) in lang):
                # Look out for duplicate streams on disk (eg DTS and DTS-HD)
                # Keep the best (assumed to be the largest)
                if self.sourceid(stream) != None:
                    # Is this a new stream or a better version of an existing stream
                    # otherwise we can ignore it (poorer version of known stream)
                    # Use sourceid to try and avoid duplicates of same audio - this is a six figure code
                    # eg 00 01 01. First four digits appear to identify main stream  and last two are sub id
                    # and could indicate language, commentary etc.
                    sourceid=self.sourceid(stream)
                    if not sourceid in streamIDs or streamIDs[sourceid]['bytes'] < self.bytes(stream):
                        # Deselect any previously selected entry
                        if sourceid in streamIDs:
                            selected.remove(streamIDs[sourceid]['stream'])

                        # Select current stream
                        selected.append(stream)
                        # And store it
                        streamIDs[sourceid]={  'stream': stream, 'bytes': self.bytes(stream)}
                else:
                    # No stream ID so add it anyway
                    selected.append(stream)
        return selected


    def video_stream(self):
        # Returns the first video stream
        for i in range(self.streams()):
            if self.codec_type(i) == 'video':
                return i
                break
        return None

    def audiomap(self, streams, reencode=['pcm.*', 'flac', 'alac', 'dts', 'truehd'],
        codec='libvorbis', quality=5,
        map=0):
        # Returns the required audiomap and conversions
        # streams -- list of the channels to be encoded
        # reencode -- list of codecs to be reencoded (otherwise copy)
        # a codec can be a regular expression pcm.* includes pcm_s16le pcm_s16be etc
        # codec -- codec to use to reencode
        # quality -- quality setting to reencode
        # map -- channel to map

        encode=[]
        s=0
        for i in streams:
            if self.codec_type(i) != 'audio':
                raise AssertionError('Expected an audio stream')

            encode.extend([ '-map', f'{map}:{i}' ])
            if re.search('|'.join(reencode), self.codec_name(i)):
                encode.extend([ f'-c:a:{s}', codec ])
                encode.extend([ f'-q:a:{s}', str(quality) ])
            else:
                encode.extend([ f'-c:a:{s}', 'copy' ])

            s+=1
        return encode


class CropDetect:
    # Identifies the points to crop a video
    def __init__(self, video_file, skip=.1):
        probe=FFProbe(video_file)
        # Points to start and stop searching the file
        video_stream=probe.video_stream()
        if probe.duration(video_stream) is not None:
            trim=[ '-ss', str(skip*probe.duration(video_stream)),
                '-to', str(probe.duration(video_stream)*(1-skip)) ]
        else:
            trim=[]

        # top left box to "delogo" video
        tlbox=f'0:0:{int(probe.width(video_stream)/6)}:{int(probe.height(video_stream)/5.7)}:black:t=fill'
        crop = subprocess.run([ 'ffmpeg' ] + trim + [ '-i', video_file,
            '-vf', f'drawbox={tlbox},cropdetect', '-f', 'null', '-' ] ,
            capture_output=True,
            universal_newlines=True)

        # Search for the crop detect result in the standard error output
        # Example output:
        # [Parsed_cropdetect_2 @ 0x5980dd8fe480] x1:0 x2:1279 y1:0 y2:1023 w:1280 h:1024 x:0 y:0 pts:134 t:268.000000 limit:0.094118 crop=1280:1024:0:0
        # We are only interested in the last crop detect (once all video has been assessed)
        match = None
        for i in crop.stderr.split('\n'):
            if i.startswith('[Parsed_cropdetect'):
                match=i

        if match:
            # We have a match -- therefore pull out all the values
            split1=match.split('=')
            split2=split1[1].split(':')
            self.w=int(split2[0])
            self.h=int(split2[1])
            self.x=int(split2[2])
            self.y=int(split2[3])
        else:
            # No match -- return null results
            self.w = None
            self.h = None
            self.x = None
            self.y = None


    def trim_x(self, x=8):
        # Reduces the horizontal (x) size of the image
        # Test x and w to make sure its not a null result
        if self.w:
            self.w -= 2*x
            self.x += x

    def trim_y(self, y=8):
        # Reduces the vertical (y) size of the image
        # Test h and y to make sure its not a null result
        if self.h:
            self.h -= 2*y
            self.y += y

    def filter(self):
        # Returns the ffmpeg filter (if not null) (if not specified, a None will be returned)
        # Just check width and height (must be not null and not zero)
        if self.w and self.h:
            return f'crop={self.w}:{self.h}:{self.x}:{self.y}'



def server(servernamefile=Path('/usr/local/etc/servername')):
    if not servernamefile.is_file:
        raise OSError('servername not specified')
    with open(servernamefile, 'r', encoding='utf-8') as f:
        return f.readline().strip()


def nlm_strength(value):
    # Limits input value for nlmeans strength to legal range 1 <= x <= 30
    fvalue=float(value)
    if fvalue < 1 or fvalue > 30:
        raise argparse.ArgumentTypeError(f'{value} is out of range (1 - 30)')
    return fvalue


def file(value):
    # Checks a file name exists and returns it as an object
    fo=Path(value)
    if fo.exists():
        return fo
    else:
        raise argparse.ArgumentTypeError(f'{value}: file not found')


if __name__ == '__main__':

    videoCodec=Path(sys.argv[0]).stem
    encoder={'h265': 'libx265',
            'av1': 'libaom-av1'
            }
    crf={'h265': {'high': 17, 'med': 20, 'low': 23},
        'av1': {'high': 23, 'med': 25, 'low': 27}
        }
    
    # Options for colour depth
    depth = { 8: 'yuv420p',
             10: 'yuv420p10le',
             12: 'yuv420p12le',
             14: 'yuv420p14le'}
    quality='med'
    lang=None # Default to including all languages
    suffix='.mkv'

    if not videoCodec in encoder:
        raise SystemExit(f'{videoCodec} is not supported')

    # Read some arguments!
    parser = argparse.ArgumentParser(description='Converts video files to h265 format')
    parser.add_argument('file_to_convert', metavar='file', type=file, nargs='+',
                   help='Filename to be converted')
    # Crop options
    parser.add_argument('-c', action='store_true', help="Don't auto crop")
    parser.add_argument('-x', action='store_true', help='crop the left and right of the image')
    parser.add_argument('-y', action='store_true', help='crop the top and bottom of the image')

    # Quality options
    parser.add_argument('-H', action='store_true', help='higher quality encode')
    parser.add_argument('-l', action='store_true', help='lower quality encode')
    parser.add_argument('-n', metavar='level', type=nlm_strength, default=None,
        help='Use noise reducing filter, (strength 1 - 30)')
    parser.add_argument('-d', metavar='bit_depth', help='specify colour bit depth',
                         choices=list(depth.keys()), action='store', default=10, type=int)

    # Select required audio language(s)
    parser.add_argument('-L', metavar='lang', action='append',
    help='Specify audio language(s) to include (default:all')

    # Aspect ratio options
    parser.add_argument('-w', action='store_true', help="Wide screen (16x9) aspect ratio")
    parser.add_argument('-s', action='store_true', help='Standard screen (4x3) aspect ratio')

    # Background mode -- no help as not a user option
    parser.add_argument('-B', action='store_true', help=argparse.SUPPRESS)

    args = parser.parse_args()

    if not args.B:
        # Foreground mode -- queue job

        # Modify the inital command to include -B as first option, and strip out the file names
        # assume file names at the end
        # so 'h265 -w file1 file2' becomes 'h265 -B -w' 
        batch_job = sys.argv[:len(sys.argv) - len(args.file_to_convert)]
        batch_job.insert(1, '-B')

        # And create a batch job for each file
        # so 'h265 -B -w file1' and 'h265 -B -w file2'
        for file in args.file_to_convert:
            subprocess.run(['ssh', server(), 'batch'],
                input=' '.join([shlex.quote(_) for _ in batch_job + [str(file.absolute())]]),
                 encoding='utf-8', capture_output=True )

    else:
        # Background mode -- process conversion
       for i in args.file_to_convert:
            video_filter=['yadif=1:-1:1']   #Always deinterlace
            # Any noise filter
            if args.n:
                video_filter.append(f'nlmeans=s={args.n}')

            # Apply quality
            if args.H:
                quality='high'
            if args.l:
                quality='low'

            # Crop if required
            if not args.c:
                cd=CropDetect(i)
                if args.x:
                    cd.trim_x()

                if args.y:
                    cd.trim_y()

                # Is there a valid filter result?
                if cd.filter():
                    video_filter.append(cd.filter())

            # Select audio stream(s)
            if args.L:
                lang=args.L

            probe=FFProbe(i)
            audio=probe.prefer_audio(lang)

             # Process aspect ratio
            if args.w:
                video_filter.append('setsar='+str(probe.height(probe.video_stream())/
                probe.width(probe.video_stream())*16/9))
            if args.s:
                video_filter.append('setsar='+str(probe.height(probe.video_stream())/
                probe.width(probe.video_stream())*4/3))

            # Build video filter
            vf = ','.join(video_filter)

            tmp = Path(tempfile.mkdtemp())
            outfile = tmp / i.with_suffix(suffix).name

            command = [ 'ffmpeg', '-y', '-i', str(i), '-flags', '+global_header', '-map',
                    '0:v', '-c:v', encoder[videoCodec], '-crf', f'{crf[videoCodec][quality]}',
                    '-pix_fmt', depth[args.d], '-vf', vf ] + probe.audiomap(audio) + ['-map', '0:s?',
                    '-c:s', 'copy', str(outfile) ]

            encode = subprocess.run(command, capture_output=True, encoding='utf-8')
            # Check it worked
            if encode.returncode == 0:
                # Delete original and replace with the new version
                i.unlink()
                shutil.move(outfile, i.with_suffix(suffix))
            else:
                # Show the command and the error message
                print (command)
                print (encode.stderr)
                outfile.unlink()

            # Tidy up -- remove the temporary directory
            tmp.rmdir()